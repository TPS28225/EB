/***********************************************************************
文件名称：main.C
功    能：
编写时间：
编 写 人：北京智嵌物联网电子技术团队
注    意：
***********************************************************************/
#include "main.h"

INPUTDEVICE_MEASURE  INPUTDEVICE;
OUTPUTDEVICE_CONTROL OUTPUTDEVICE;
OS_EVENT * q_msg;			//消息队列
void * MsgGrp[64];			//消息队列存储地址,最大支持64个消息
int main(void)
{
	//初始化板子
//	BSP_Init();
//	//初始化系统
//	OSInit();
//	//创建启动任务
//	OSTaskCreate(	Task_StartUp,               		    										//指向任务代码的指针
//                (void *) 0,																							//任务开始执行时，传递给任务的参数的指针
//								(OS_STK *)&Stk_TaskStartUp[TASK_STARTUP_STK_SIZE - 1],	//分配给任务的堆栈的栈顶指针   从顶向下递减
//								(INT8U) OS_USER_PRIO_LOWEST);														//分配给任务的优先级  

//	//节拍计数器清0  
//	OSTimeSet(0);

//	//启动UCOS-II内核
//	OSStart();

//	return 0;
//}
////启动任务堆栈
//OS_STK Stk_TaskStartUp[TASK_STARTUP_STK_SIZE];

//void Task_StartUp(void *pdata)
//{

////初始化UCOS时钟
////OS_TICKS_PER_SEC 为 UCOS-II 每秒嘀嗒数
//	SysTick_Config(SystemCoreClock/OS_TICKS_PER_SEC - 1);

////优先级说明，使用OS_USER_PRIO_GET(n)宏来获取
////OS_USER_PRIO_GET(0)最高,OS_USER_PRIO_GET(1)次之，依次类推
////OS_USER_PRIO_GET(0)：最高的优先级，主要用于在处理紧急事务，需要将优先处理的任务设置为最高这个优先级  

////OSTaskCreate(	Task_Xxx,               		    							//指向任务代码的指针
////              (void *)0,																		//任务开始执行时，传递给任务的参数的指针
////				(OS_STK *)&Stk_TaskXxx[TASK_XXX_STK_SIZE - 1],			//分配给任务的堆栈的栈顶指针   从顶向下递减
////				(INT8U) OS_USER_PRIO_GET(N));												//分配给任务的优先级  

//	q_msg=OSQCreate(&MsgGrp[0],64);	//创建消息队列
//		
//	OSTaskCreate(Task_UDP_Client, (void *)0, &Stk_Task_UDP_Client[TASK_UDP_CLIENT_STK_SIZE-1], OS_USER_PRIO_GET(5));
//	OSTaskCreate(Task_LED,(void *)0, &Stk_Task_LED[TASK_TEST_LED_STK_SIZE-1], OS_USER_PRIO_GET(6));
//	OSTaskCreate(Task_TX, (void *)0, &Stk_Task_TX[TASK_TEST_TX_STK_SIZE-1], OS_USER_PRIO_GET(3));
//  OSTaskCreate(Task_RX, (void *)0, &Stk_Task_RX[TASK_TEST_RX_STK_SIZE-1], OS_USER_PRIO_GET(2));
//	
//	//传感器任务调度
//	OSTaskCreate(Task_devicemanager, (void *)0, &Stk_Task_DEVICEMANAGER[TASK_DEVICEMANAGER_STK_SIZE-1], OS_USER_PRIO_GET(9));
////	OSTaskCreate(Task_UltrasonicWave,(void *)0, &Stk_Task_UltrasonicWave[TASK_UltrasonicWave_STK_SIZE-1], OS_USER_PRIO_GET(10));
////	OSTaskCreate(Task_DHT11, (void *)0, &Stk_Task_DHT11[TASK_DHT11_STK_SIZE-1], OS_USER_PRIO_GET(11));
////  OSTaskCreate(Task_SOUNDSENSOR, (void *)0, &Stk_Task_SOUNDSENSOR[TASK_SOUNDSENSOR_STK_SIZE-1], OS_USER_PRIO_GET(12));
////	OSTaskCreate(Task_HUMANBODYSENSOR,(void *)0, &Stk_Task_HUMANBODYSENSOR[TASK_HUMANBODYSENSOR_STK_SIZE-1], OS_USER_PRIO_GET(13));
////	OSTaskCreate(Task_LIGHTINTENSITYSENSOR, (void *)0, &Stk_Task_LIGHTINTENSITYSENSOR[TASK_LIGHTINTENSITYSENSOR_STK_SIZE-1], OS_USER_PRIO_GET(14));
////  OSTaskCreate(Task_RFID, (void *)0, &Stk_Task_RFID[TASK_RFID_STK_SIZE-1], OS_USER_PRIO_GET(15));
//	
////	OSTaskSuspend(OS_USER_PRIO_LOWEST);
//	while (1)
//	{
//		//循环看守程序执行情况
//		//通常情况下这里使一个系统状态灯闪烁，表示系统正在运行
//		//GPIO_ToggleBits(LED2);
//		//GPIO_ToggleBits(LED3);
//		OSTimeDlyHMSM(0, 0, 0, 1000);//1000ms
//	}



}





//	delay_init();
//	OLED_Init();
//	
//	OLED_Display_Off();

//	OLED_Display_On();

//	OLED_test();
//	
//	//????
//	OLED_CLS();
//	OLED_ShowChar(0,0,'a',12,1);											    
//	OLED_Refresh_Gram();//????
//	OLED_DLY_ms(5000);
//	
//		//????
//			OLED_CLS();  
//			OLED_ShowNum(0,0,333,3,12);											    
//	    OLED_Refresh_Gram();//????	

//			OLED_CLS();
//	    OLED_DrawPoint(0,2,1);
//	    OLED_DrawPoint(0,3,1);
//	    OLED_DrawPoint(0,4,1);
//			OLED_Refresh_Gram();

//		OLED_ShowString(0,0,"First");	
//		OLED_ShowString(48,0,"Second");	
//		OLED_ShowString(16,16,"Third");	
//		OLED_ShowString(103,48,"END");											    
//		OLED_Refresh_Gram();


//		Oled_Horizontal_Scrolling();
//		Oled_Vertical_Scrolling();
//		Oled_Vertical_Horizontal_Scrolling();
//	while(1)
//	{
//		    
//	}






//int i1=0;
//int zhuansu=2000;
//	delay_init();
//	Stepper_Motor_Init();
//	
//	while(1)
//	{
//		Stepper_Motor_Control();
//		delay_us(zhuansu);
//		i1++;
//		if(i1>100)
//		{
//			i1=0;
//			if(zhuansu>200)zhuansu-=10;
//		}
//	}



//	extern const unsigned char BMP1[];
//	delay_init();
//	OLED_Init();
//	
//	OLED_Display_Off();

//	OLED_Display_On();
//	
//	OLED_CLS();  
//	OLED_test();
//	while(1)
//	{
//	}





char *string="滚滚长江东aaaa";
//char bmp1[]={
//0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
//0x80,0x00,0x0F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x3F,0xC0,0x00,0x07,0x07,0x00,0x04,0x01,0x00,0x00,0x38,0x60,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x78,0xE0,0x00,0x3F,0x83,0x80,0x06,0x03,0x80,0x00,0x1C,0x70,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x02,0x38,0x70,0x00,0xFF,0x07,0x80,0x06,0x39,0x80,0x00,0x1F,0x70,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x02,0x1C,0x30,0x00,0x7C,0x0E,0x00,0x06,0x19,0xC0,0x00,0x1F,0x80,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x02,0x1C,0x30,0x00,0x3E,0x1C,0x00,0x06,0x1F,0xC0,0x00,0x7F,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x03,0x3E,0x30,0x00,0x62,0x1A,0x00,0x0F,0x79,0x00,0x03,0xFE,0x00,0x00,0x01,
//0x80,0x00,0x00,0x60,0x0F,0x00,0x3F,0x00,0x00,0x00,0x3C,0x00,0xC0,0x00,0x00,0x01,
//0x80,0x07,0x76,0x18,0x00,0xC3,0xC1,0x00,0x1F,0xFB,0x00,0x03,0xFE,0x00,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x3F,0xC0,0xF1,0xC0,0x00,0x00,0xF0,0x01,0xC0,0x00,0x00,0x01,
//0x80,0x07,0x6E,0x18,0x00,0xCF,0xC1,0x80,0x7E,0x3F,0x80,0x01,0xE2,0x00,0x00,0x01,
//0x80,0x00,0x07,0xE0,0x7F,0xE0,0xE0,0xE0,0x00,0x03,0xC0,0x03,0xC0,0x00,0x00,0x01,
//0x80,0x07,0x7F,0x98,0x00,0xFE,0x83,0x81,0xFC,0x1E,0xC0,0x00,0x83,0x00,0x00,0x01,
//0x80,0x00,0x0F,0xE0,0x63,0xE1,0xE0,0xE0,0x00,0x07,0x00,0x03,0xC0,0x00,0x00,0x01,
//0x80,0x06,0xFF,0xD8,0x01,0xFA,0x87,0x00,0xFD,0xF8,0xC0,0x01,0x73,0x00,0x00,0x01,
//0x80,0x00,0x01,0xE0,0xC1,0xE1,0xE0,0xE0,0x00,0x0F,0x00,0x07,0xC0,0x00,0x00,0x01,
//0x80,0x0F,0xD9,0xD8,0x03,0xE3,0x0E,0x80,0xFE,0x7E,0xC0,0x03,0xF9,0x80,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x01,0xE1,0xF0,0xE0,0x00,0x1E,0x00,0x0B,0xC0,0x00,0x00,0x01,
//0x80,0x0D,0xB8,0x18,0x1F,0xC3,0x08,0xC0,0x0E,0x6D,0x80,0x03,0xF1,0x80,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x01,0xE0,0xFD,0xC7,0xEF,0x9E,0x00,0x13,0xC0,0x00,0x00,0x01,
//0x80,0x0D,0xFE,0x18,0x0F,0xC2,0x10,0xE0,0x1C,0x3F,0x00,0x03,0xE0,0xC0,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x01,0xC0,0xFF,0x83,0xC6,0x1F,0xE0,0x13,0xC0,0x00,0x00,0x01,
//0x80,0x0D,0xCE,0x18,0x06,0xC2,0x01,0xC0,0x38,0x3E,0x00,0x00,0xE8,0xC0,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x01,0x80,0x3F,0x81,0xE4,0x3C,0x78,0x23,0xC0,0x00,0x00,0x01,
//0x80,0x0C,0x4C,0x18,0x00,0xC2,0x03,0x80,0x78,0x1F,0xF0,0x00,0xFC,0x60,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x03,0x80,0x3F,0xC1,0xE8,0x3C,0x78,0x43,0xC0,0x00,0x00,0x01,
//0x80,0x0C,0x5E,0x18,0x00,0xC2,0x07,0x00,0x68,0x3F,0xF8,0x03,0xFC,0x22,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x03,0x00,0x6F,0xC0,0xF0,0x3C,0x3C,0x83,0xC0,0x00,0x00,0x01,
//0x80,0x06,0x3F,0x38,0x01,0x82,0x0E,0x00,0x09,0xF8,0x00,0x03,0xC0,0x32,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x06,0x00,0xC3,0xE0,0x78,0x3C,0x3C,0xFF,0xF0,0x00,0x00,0x01,
//0x80,0x07,0x10,0x38,0x00,0x82,0x1C,0x00,0x0B,0x99,0xC0,0x03,0x00,0x1A,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x0C,0x11,0xC3,0xE0,0x78,0x3C,0x3C,0xFF,0xF0,0x00,0x00,0x01,
//0x80,0x03,0xFF,0xF0,0x00,0x02,0x38,0x00,0x08,0x30,0xE0,0x02,0x00,0x1E,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x08,0x11,0xC1,0xE0,0x7C,0x3C,0x3C,0xFF,0xF0,0x00,0x00,0x01,
//0x80,0x01,0xEF,0xF0,0x00,0x00,0xE0,0x00,0x08,0xE0,0x60,0x00,0x00,0x0E,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x1F,0xF1,0xC1,0xE0,0xBC,0x1C,0x3C,0x03,0xC0,0x00,0x00,0x01,
//0x80,0x00,0x03,0xE0,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x07,0x00,0x01,
//0x80,0x00,0x01,0xE0,0x3F,0xE1,0xC1,0xC0,0x9E,0x1E,0x38,0x03,0xC0,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,
//0x80,0x00,0x01,0xF0,0x7F,0xE0,0xE3,0x83,0x1F,0x0E,0x70,0x03,0xC0,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x0F,0xFC,0xFF,0xE0,0x3F,0x07,0xDF,0x83,0xE0,0x03,0xC0,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
//0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x01,
//0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
//};

//	delay_init();
//	LCD12864_Init();                          //LCD???
//	PutStr(1,1,string);
//	LcmClearTXT();
//  PutBMP(bmp1);
//	while(1);








//UltrasonicWave_Configuration();

// while(1)
// {
//	UltrasonicWave_StartMeasure();
//	delay_ms(60); 
// }




// 	GPIO_InitTypeDef  GPIO_InitStructure;
// 	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);	 //使能PA端口时钟
//	
// 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;				 //PA4端口配置
// 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; 		 //推挽输
//	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
// 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
// 	GPIO_Init(GPIOA, &GPIO_InitStructure);				 //初始化IO口
//	
//	delay_init();

//	DHT11_Init();
//	
//	while(1)
//	{
//		
//		DHT11_Read_Data(&INPUTDEVICE.temperature, &INPUTDEVICE.humidity);
//		delay_us(1000000);
//		GPIO_SetBits(GPIOA, GPIO_Pin_4);						 //PA4 输出高
//		delay_ms(1000);
//		GPIO_ResetBits(GPIOA, GPIO_Pin_4);						 //PA4 输出高
//	}



// 	GPIO_InitTypeDef  GPIO_InitStructure;
// 	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);	 //使能PA端口时钟
//	
// 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;				 //PA4端口配置
// 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; 		 //推挽输
//	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
// 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
// 	GPIO_Init(GPIOA, &GPIO_InitStructure);				 //初始化IO口
//	
//	delay_init();

//	soundsensor_init();
//	
//	while(1)
//	{
//		
//		soundsensor_measure();
//		delay_us(1000000);
//		GPIO_SetBits(GPIOA, GPIO_Pin_4);						 //PA4 输出高
//		delay_ms(1000);
//		GPIO_ResetBits(GPIOA, GPIO_Pin_4);						 //PA4 输出高
//	}







// 	GPIO_InitTypeDef  GPIO_InitStructure;
// 	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);	 //使能PA端口时钟
//	
// 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;				 //PA4端口配置
// 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; 		 //推挽输
//	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
// 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
// 	GPIO_Init(GPIOA, &GPIO_InitStructure);				 //初始化IO口
//	
//	delay_init();

//	humanbodysensor_init();
//	
//	while(1)
//	{
//		
//		humanbodysensor_measure();
//		delay_us(1000000);
//		GPIO_SetBits(GPIOA, GPIO_Pin_4);						 //PA4 输出高
//		delay_ms(1000);
//		GPIO_ResetBits(GPIOA, GPIO_Pin_4);						 //PA4 输出高
//	}




// 	GPIO_InitTypeDef  GPIO_InitStructure;
// 	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);	 //使能PA端口时钟
//	
// 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;				 //PA4端口配置
// 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; 		 //推挽输
//	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
// 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
// 	GPIO_Init(GPIOA, &GPIO_InitStructure);				 //初始化IO口
//	
//	delay_init();

//	LightIntensitySensor_Init();
//  	
//	while(1)
//	{		
//		LightIntensitySensor_measure(&(INPUTDEVICE.LightIntensity)); 
//		delay_ms(1000);
//		GPIO_SetBits(GPIOA, GPIO_Pin_4);						 //PA4 输出高
//		delay_ms(1000);
//		GPIO_ResetBits(GPIOA, GPIO_Pin_4);						 //PA4 输出高
//	}



//	uint8_t i;
//	uint8_t Card_Type1[2];
//	uint8_t Card_ID[4];
//	uint8_t Card_KEY[6] = {0xff,0xff,0xff,0xff,0xff,0xff};    //{0x11,0x11,0x11,0x11,0x11,0x11};   //??
//	uint8_t Card_Data[16];
//	uint8_t status;
//	
//	delay_init();
//	uart_init(115200);	 //串口初始化为115200
//	RC522_Init();
//  	
//	while(1)
//	{
//		delay_ms(10);
//		if(MI_OK==PcdRequest(0x52, Card_Type1))
//		{
//			uint16_t cardType = (Card_Type1[0]<<8)|Card_Type1[1];
//			printf("Card Type(0x%04X):",cardType);
//			switch(cardType){
//			case 0x4400:
//					printf("Mifare UltraLight\n\r");
//					break;
//			case 0x0400:
//					printf("Mifare One(S50)\n\r");
//					break;
//			case 0x0200:
//					printf("Mifare One(S70)\n\r");
//					break;
//			case 0x0800:
//					printf("Mifare Pro(X)\n\r");
//					break;
//			case 0x4403:
//					printf("Mifare DESFire\n\r");
//					break;
//			default:
//					printf("Unknown Card\n\r");
//					continue;
//			}
//			//delay_ms(10);
//			status = PcdAnticoll(Card_ID);//防冲撞
//			if(status != MI_OK){
//					printf("Anticoll Error\n\r");
//					continue;
//			}else{
//					printf("Serial Number:%02X%02X%02X%02X\n\r",Card_ID[0],Card_ID[1],Card_ID[2],Card_ID[3]);
//			}
//			status = PcdSelect(Card_ID);  //选卡
//			if(status != MI_OK){
//					printf("Select Card Error\n\r");
//					continue;
//			}
//			status = PcdAuthState(PICC_AUTHENT1A,CARDBLOCKNUM,Card_KEY,Card_ID);
//			if(status != MI_OK){
//					printf("Auth State Error\n\r");
//					continue;
//			}
//			memset(Card_ID,1,4);
//			
////			memset(Card_Data,1,16);
////			Card_Data[0]=0xaa;
////			status = PcdWrite(5,Card_Data);                   //写入0XAA,0X01,0X01……
////			if(status != MI_OK){
////					printf("Card Write Error\n\r");
////					continue;
////			}
////			memset(Card_Data,0,16);
//			
//			delay_us(8);
//			
//			status = PcdRead(CARDBLOCKNUM,Card_Data);                    //再一次把它读取出来16字节的卡片数据
//			if(status != MI_OK){
//					printf("Card Read Error\n\r");
//					continue;
//			}else{
//				for(i=0;i<16;i++){
//					printf("%02X ",Card_Data[i]);
//				}
//				printf("from block:%d\n\r",CARDBLOCKNUM);
//				
//			}			
//			memset(Card_Data,2,16);
//			PcdHalt();
//			
//			CARDBLOCKNUM++;
//			if(CARDBLOCKNUM==63)CARDBLOCKNUM=0;
//		}
//	}





//	delay_init();
//	Lcd_Init();

//	Lcd_Clear(BLACK);
//	
//	delay_ms(200);
//	Lcd_Clear(RED);
//	Lcd_Test(WHITE);
////	Gui_DrawPoint(0,0,WHITE);
//	while(1)
//	{

////		Lcd_Clear(WHITE);

////		Lcd_Clear(BLACK);

////		Lcd_Clear(RED);

////	  Lcd_Clear(GREEN);

////	  Lcd_Clear(BLUE);

//	}